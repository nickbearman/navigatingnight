[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Navigating the Night",
    "section": "",
    "text": "Welcome\nThis is the website for Navigating the Night, a workshop at GISRUK2024 given by Dr. Elisabetta Pietrostefani from the University of Liverpool, sponsored by the RGS-IBG Quantitative Methods Research Group (QMRG). The theme of the GISRUK 2024 is GIS for public good: data, theory, policy.\nThis workshop introduces students to raster data focusing on night lights. Night time satellite images show luminosity - i.e. the brightness of a place at night. The idea is that luminosity correlates strongly with economic activity and can be especially useful in data poor contexts where other economic data is not collected.\nThe website is free to use and is licensed under the Attribution-NonCommercial-NoDerivatives 4.0 International. A compilation of this web course is hosted as a GitHub repository that you can access:"
  },
  {
    "objectID": "mapraster.html#raster-data",
    "href": "mapraster.html#raster-data",
    "title": "Raster",
    "section": "Raster Data",
    "text": "Raster Data\nRaster data is a digital image format that represents data as a grid of individual pixels, with each pixel containing a specific value or color information.\n\nSquare grid of pixels.\nPixel values can represent continuous or categorical variables:\n\nDivides 2-D space into regular cells - pixels\nEach cell has a single value\n\nValues assigned according to value at mean, centre point, or some other rule"
  },
  {
    "objectID": "mapraster.html#data-types",
    "href": "mapraster.html#data-types",
    "title": "Raster",
    "section": "Data Types",
    "text": "Data Types\n\nGrayscale Rasters\nGrayscale raster data is a type of digital image representation that uses varying shades of gray to depict the intensity or brightness of a particular phenomenon at different locations. In grayscale images, pixel values typically range from 0 (black) to 255 (white), with intermediate values representing different levels of gray. These pixel values can represent continuous data, making grayscale rasters suitable for visualizing and analyzing phenomena where intensity or variation needs to be conveyed, such as medical X-rays, satellite nightlights data, or other scenarios where the focus is on quantifying the degree of a single attribute without using color.\nExample: Nightlights Data\nNightlights data can be represented as a grayscale raster, where darker areas indicate lower levels of artificial light, and lighter areas represent higher levels of artificial light. The pixel values may represent the radiance or luminance values of nighttime lights. Satellite-based nightlights data is used for various applications, such as monitoring urban development, assessing light pollution, and understanding human activity patterns at night.\n\n\n\n\n\n\n\nMultispectral Rasters\nMultispectral rasters are a type of digital image representation that incorporates multiple spectral bands or channels to capture a diverse range of information about a scene or phenomenon. In multispectral rasters, each channel represents a specific part of the electromagnetic spectrum, such as visible light, near-infrared, or thermal infrared. By combining these spectral bands, multispectral data provides a comprehensive view of the landscape, enabling analysis of various aspects like vegetation health, land use, or changes in urban and rural conditions. This type of raster data is commonly used in applications such as remote sensing, agriculture, and natural resource management, where a nuanced understanding of different attributes of the environment is essential.\nExample: Landsat Satellite Imagery\nLandsat satellite imagery, with its multispectral bands, is extensively used for environmental monitoring. It allows for tracking changes in land cover, assessing vegetation health, monitoring water quality, and detecting forest fires. Researchers and environmental agencies use multispectral data to make informed decisions regarding conservation and resource management.\n\n\n\n\n\n\n\nColor Rasters\nColour rasters are a digital image representation that utilizes the combination of three primary colour channels: red, green, and blue (RGB) to create a full range of colors. Each pixel in a colour raster is assigned values for these three color channels, which determine the pixel’s color.\nExample: Digital Photographs\nColour rasters, as seen in digital photographs can be used for social sciences by analysing pixel differences.\n\n\n\n\n\n\n\nElevation Rasters\nElevation rasters are a type of digital representation that use a grid of values to depict the varying heights or elevations of the Earth’s surface across different locations. Each pixel in an elevation raster contains a numerical value representing the height or elevation above a reference point, such as sea level. Elevation rasters are commonly used in geospatial applications, cartography, and terrain modeling. They enable precise visualization and analysis of topographic features, such as mountains, valleys, and slopes, making them essential for tasks like mapmaking, land-use planning, flood risk assessment, and 3D visualization of landscapes.\nExample: Digital Elevation Models (DEMs)\nDEMs are vital for creating topographic maps, analyzing terrain, and conducting spatial modeling. They find applications in urban planning, flood risk assessment, route planning, and 3D visualization. DEMs enable precise representation of Earth’s surface elevation, supporting a wide range of geospatial applications."
  },
  {
    "objectID": "mapraster.html#some-surprising-facts-about-nightlights-data",
    "href": "mapraster.html#some-surprising-facts-about-nightlights-data",
    "title": "Raster Data",
    "section": "Some surprising facts about nightlights data",
    "text": "Some surprising facts about nightlights data\nhttps://yohaniddawela.substack.com/p/some-surprising-facts-about-nightlights"
  },
  {
    "objectID": "mapraster.html#satellite-data-for-social-science",
    "href": "mapraster.html#satellite-data-for-social-science",
    "title": "Raster Data",
    "section": "Satellite data for Social Science",
    "text": "Satellite data for Social Science\nHave a look at\n\nJean, Neal, et al. 2016 “Combining satellite imagery and machine learning to predict poverty.” Science\nHenderson, J. Vernon, Adam Storeygard, and David N. Weil. 2012. Measuring Economic Growth from Outer Space American Economic Review, 102 (2): 994-1028. Replication data"
  },
  {
    "objectID": "mapraster.html#further-readings",
    "href": "mapraster.html#further-readings",
    "title": "Raster",
    "section": "Further readings",
    "text": "Further readings\n\nRaster Data in R"
  },
  {
    "objectID": "index.html#contact",
    "href": "index.html#contact",
    "title": "Navigating the Night",
    "section": "Contact",
    "text": "Contact\n\nElisabetta Pietrostefani - e.pietrostefani [at] liverpool.ac.uk Lecturer in Geographic Data Science, University of Liverpool."
  },
  {
    "objectID": "mapraster_code.html#installing-packages",
    "href": "mapraster_code.html#installing-packages",
    "title": "Lab 1",
    "section": "Installing Packages",
    "text": "Installing Packages\n\n# Provides various utility functions for R programming.\nlibrary(R.utils)\n# For data manipulation and transformation.\nlibrary(dplyr)\n# Spatial data\nlibrary(sf)\n# Popular data visualization package in R.  \nlibrary(ggplot2)\n# For creating thematic maps \nlibrary(tmap)\n# Color palettes suitable for data visualization, especially for those with color vision deficiencies.\nlibrary(viridis)\n# A collection of color palettes for data visualization.\nlibrary(RColorBrewer)\n# For working with raster data, such as gridded spatial data like satellite imagery or elevation data.\nlibrary(raster)\n# An alternative to the 'raster' package and is used for working with large raster datasets efficiently.\nlibrary(terra)\n# Tools for extracting data from raster layers at exact locations, often used in spatial analysis.\nlibrary(exactextractr)\n# Common methods of the tidyverse packages for objects created with the {terra} package: SpatRaster and SpatVector\nlibrary(tidyterra)\n# Querying Open Street Map data\nlibrary(osmdata)\n\n\n\n\n\n\n\nImportant\n\n\n\nImportant packages for raster data in R.\n\nterra: the best way of loading and processing raster data.\nsf: the go-to package for dealing with polygons, lines and spatial points.\nexactextractor: the quickest, easiest and most accurate way to calculate zonal statistics. It’s an R wrapper for the exactextract package (written in C++). It’s more accurate than ArcGIS, QGIS, and Python’s rasterstats package in calculating zonal stats.\ntmap: quick and easy, and its “view” mode allows you to create interactive maps that are built on leaflet.\nggplot: the best package for building beautiful maps. Allows for more customisation than tmap.\n\nThere are also the following packages which we will not be using in this workshop:\n\nrgeedim: provides the easiest way to download data directly from Google Earth Engine as GeoTiffs.\nrgee: an R wrapper for Google Earth Engine, so you can run GEE commands in R\ngganimate: a package that allows you to turn your ggplot2 graphs into gifs.\nrayshader: create animated 3D graphs and maps in R.\ncountrycode: a useful package to automatically generate ISO codes from country names (and vice versa), assign continents to countries.\ndoparallel: my go-to package for parallel processing."
  },
  {
    "objectID": "mapraster_code.html#terrain-data",
    "href": "mapraster_code.html#terrain-data",
    "title": "Lab",
    "section": "Terrain data",
    "text": "Terrain data\n\nImport raster data\nRaster terrain data consists of gridded elevation values that represent the topography of a geographic area. You can download this from the relevant github folder. A good place to download elevation data is Earth Explorer. This video takes you through the download process if you want to try this out yourself.\nWe first import a raster file for elevation.\n\nMENA_lights &lt;- rast(\"data/MENA_noaa_projected.tif\")\n\nPlot it.\n\nplot(MENA_lights) \n\n\n\n\nHave a look at the CRS.\n\ncrs(MENA_lights)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        DATUM[\\\"World Geodetic System 1984\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Albers Equal Area\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"easting\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]],\\n        AXIS[\\\"northing\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]]]\"\n\n\n\n\nImport the Lebanon shapefile\nImport the Lebanon shapefile, plot it, and verify its Coordinate Reference System (CRS). Is it the same as the raster’s CRS?\n\nMENA_adm1 &lt;- read_sf(\"data/MENA_projected.shp\")\nplot(MENA_adm1$geometry)\n\n\n\ncrs(MENA_adm1)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Not known.\\\"],\\n        AREA[\\\"Africa\\\"],\\n        BBOX[-35,-25,39,55]],\\n    ID[\\\"ESRI\\\",102022]]\"\n\n\n\n\nReproject the Raster\nAs we are using both the raster and terra packages to handle the raster data it is useful to write terra:: or raster:: in front of the function we are using.\nWe use the terra project() function, we need to define two things:\n\nThe object we want to reproject and\nThe CRS that we want to reproject it to.\n\n\nMENA_lights &lt;- terra::project(MENA_lights, crs(MENA_adm1)) # reporjectig the elevation data to the crs of the Lebanon shapefile\ncrs(MENA_lights)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Not known.\\\"],\\n        AREA[\\\"Africa\\\"],\\n        BBOX[-35,-25,39,55]],\\n    ID[\\\"ESRI\\\",102022]]\"\n\n\n\n\nCropping and Masking\nCropping and masking are both spatial operations used in raster data analysis.\nCropping:\n\nPurpose: Cropping a raster involves changing the extent of the raster dataset by specifying a new bounding box or geographic area of interest. The result is a new raster that covers only the specified region.\nTypical Use: Cropping is commonly used when you want to reduce the size of a raster dataset to focus on a smaller geographic area of interest while retaining all the original data values within that area.\n\nMasking:\n\nPurpose: Applying a binary mask to the dataset. The mask is typically a separate raster or polygon layer where certain areas are designated as “masked” (1) or “unmasked” (0).\nTypical Use: Masking is used when you want to extract or isolate specific areas or features within a raster dataset. For example, you might use a mask to extract land cover information within the boundaries of a protected national park.\n\nIn many cases, these cropping and masking are executed one after the other because it is computationally easier to crop when dealing with large datasets, and then masking.\n\nMENA_lights_crop &lt;- crop(MENA_lights, extent(MENA_adm1))\nMENA_lights_mask &lt;- mask(MENA_lights_crop, MENA_adm1)\n\n\n\nPlot elevation\n\nplot(MENA_lights_mask)\nplot(MENA_adm1$geometry, col= NA, add=T)\n\n\n\n\nLet’s improve this a bit. Remember that there is a lot we can do with ColorBrewer.\n\nplottmap\n\n\n\npal = rev(brewer.pal(6,\"YlGnBu\"))\nplot(MENA_lights_mask, breaks=c(0,10,20,30,40,Inf), col=pal)\nplot(MENA_adm1$geometry, col= NA, add=T)\n\n\n\n\n\n\n\n# Define the palette\npal = rev(brewer.pal(6,\"YlGnBu\"))\n\n# Create the base map\ntm_shape(MENA_lights_mask) +\n  tm_raster(breaks = c(0,10,20,30,40,Inf),\n            palette = pal) +  # Plot the raster with breaks and palette\n  tm_shape(MENA_adm1) +\n  tm_borders(lwd = 1, col = \"darkgrey\") +  # Add borders to the administrative boundaries\ntm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = \"right\", \n          title = \"Night light intensity\")  # Remove frame\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\nQuestions to ask yourself about how you can improve these maps, going back to geo-visualisation and choropleths.\n\nWhat are the logical breaks for night lights data?\nWhat should the colours be?\nHave a look at some of the tmap documentation to improve your map further .\n\n\n\n\n\nSpatial join with vector data\n\n# Subset MENA_adm1 to select only Egypt\nEgypt &lt;- MENA_adm1 %&gt;%\n  filter(name == \"Egypt\")\n\n# Crop MENA_adm1 raster to Egypt\nEgypt_lights_mask &lt;- crop(MENA_lights_mask, extent(Egypt))\n\n\n# creating bounding box for Lagos\negypt_bb &lt;- getbb(\"Cairo Egypt\")\ncairo &lt;- opq(bbox = egypt_bb)\n\namenities &lt;- cairo %&gt;%\n   add_osm_feature(key = \"amenity\", value = c(\"hospital\")) %&gt;%\n   osmdata_sf ()\n\n# Extracting points from the OSM data\namenities_points &lt;- amenities$osm_points\n\n# Plotting\nggplot() + \n  geom_sf(data = amenities$osm_points, fill = 'orange') + \n  geom_spatraster(data=Egypt_lights_mask, alpha = 0.5) +\n  coord_sf(xlim = c(30.852356, 31.717529), ylim = c(29.699982, 30.473532)) + theme_minimal()\n\n&lt;SpatRaster&gt; resampled to 501014 cells for plotting\n\n\n\n\n# Plotting\nggplot() + \n  geom_sf(data = amenities$osm_points, aes(color = \"Hospitals\"), fill = 'red', size = 1, stroke = 1, color = \"darkred\") + \n  geom_spatraster(data = Egypt_lights_mask, aes(fill = ..value..), alpha = 0.5) +\n  scale_fill_gradient(low = \"black\", high = \"yellow\", name = \"Night Lights\") +\n  coord_sf(xlim = c(30.852356, 31.717529), ylim = c(29.699982, 30.473532)) + \n  labs(title = \"Distribution of Hospitals and Night Lights in Egypt\",\n       x = \"Longitude\", y = \"Latitude\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n&lt;SpatRaster&gt; resampled to 501014 cells for plotting\n\n\nWarning: The dot-dot notation (`..value..`) was deprecated in ggplot2 3.4.0.\nℹ Please use `after_stat(value)` instead.\n\n\n\n\n\nhttps://dieghernan.github.io/tidyterra/reference/geom_spatraster.html\nYou might want to extract values from a raster data set, and then map them eith in a vector sf framework or extract them to analyse them statistically. If it therefore very useful to know hoe to extract:\n\n# Using the 'raster::extract' function, it calculates the elevation values at the coordinates of the points. 'elevation' is a raster layer, and 'households' is point data representing household locations.\nlights_hospitals &lt;- raster::extract(Egypt_lights_mask,\n                                amenities_points)\n\nWarning: [extract] transforming vector data to the CRS of the raster\n\n# Attach elevation at each point to the original housesales dataframe\nlights_hospitals &lt;- cbind(amenities_points, lights_hospitals)\n\n# Keep only specified columns\nlights_hospitals &lt;- lights_hospitals %&gt;%\n  select(MENA_noaa_projected, ID, geometry, osm_id)\n\n# Check out the data\nhead(lights_hospitals)\n\nSimple feature collection with 6 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 31.2256 ymin: 30.06897 xmax: 31.29417 ymax: 30.08557\nGeodetic CRS:  WGS 84\n          MENA_noaa_projected ID    osm_id                  geometry\n32538148                   63  1  32538148 POINT (31.29417 30.06897)\n272580023                  63  2 272580023 POINT (31.22562 30.08249)\n272580024                  63  3 272580024  POINT (31.2256 30.08322)\n272580025                  63  4 272580025 POINT (31.22574 30.08381)\n272580026                  63  5 272580026 POINT (31.22597 30.08485)\n272580027                  63  6 272580027 POINT (31.22584 30.08557)\n\n\n\n\n\n\n\n\nImportant\n\n\n\nMake sure all your data is in the same CRS, otherwise the raster::extract function will not work properly.\nYou should not be seeing NAs, if you do you should use the terra project() function."
  },
  {
    "objectID": "nightlights.html#using-nightlights-to-measure-economic-activity",
    "href": "nightlights.html#using-nightlights-to-measure-economic-activity",
    "title": "Night Lights",
    "section": "Using nightlights to measure economic activity",
    "text": "Using nightlights to measure economic activity\nThere were a few studies in the 1990s and 2000s that looked at using nighttime luminosity as a proxy for economic activity such as Elvidge et al. (1997), and Doll et al. (2006).\nA paper published in the prestigious economics journal, the American Economic Review (Henderson et al., 2012), marked turning point.\nIt argued that growth rates of nightlights were useful in two scenarios:\n\nWhen countries lacked high-quality official GDP estimates;\nWhere official sub-national GDP was unavailable\n\nThey also argued that luminosity data is available immediately, as opposed to official GDP data which can have delayed publication of a few months.\nNightlights are now one of the standard method for calculating subnational economic activity.\nIn light of the widespread use of nightlights, numerous studies neglect to discuss the specifics of what they capture, as well as their advantages and disadvantages.\nAs a result, let us examine a few of the most important concerns."
  },
  {
    "objectID": "nightlights.html#spatial-mismatches-between-production-and-consumption-at-night",
    "href": "nightlights.html#spatial-mismatches-between-production-and-consumption-at-night",
    "title": "Night Lights",
    "section": "Spatial mismatches between production and consumption at night",
    "text": "Spatial mismatches between production and consumption at night"
  },
  {
    "objectID": "nightlights.html#distinguishing-urban-vs-rural-areas",
    "href": "nightlights.html#distinguishing-urban-vs-rural-areas",
    "title": "Night Lights",
    "section": "Distinguishing urban vs rural areas",
    "text": "Distinguishing urban vs rural areas"
  },
  {
    "objectID": "nightlights.html#other-sources-of-noise-in-nightlights-data",
    "href": "nightlights.html#other-sources-of-noise-in-nightlights-data",
    "title": "Night Lights",
    "section": "Other sources of noise in nightlights data",
    "text": "Other sources of noise in nightlights data"
  },
  {
    "objectID": "nightlights.html#not-all-satellite-data-is-the-same.-there-are-actually-three-different-sources-of-free-night-time-data",
    "href": "nightlights.html#not-all-satellite-data-is-the-same.-there-are-actually-three-different-sources-of-free-night-time-data",
    "title": "Night Lights",
    "section": "Not all satellite data is the same. There are actually three different sources of free night time data:",
    "text": "Not all satellite data is the same. There are actually three different sources of free night time data:\n\nDMSP-OLS (low-resolution data)\n\nSource 1: DMSP-OLS data\nIt is: • available from 1992-2013, • low resolution (each pixel is ~1km x 1km), • the most widely used luminosity dataset in spatial economics\nIt also faces an issue of ‘overglow’.\nThis is where light from one region is picked up by another region.\n\nVIIRS (provided by Colorado School of Mines)\n\nSource 2: VIIRS data (provided by Colorado School of Mines and (noaa?) )\nThis is:\n• available from 2012-present • doesn’t experience overglow • high resolution (each pixel is ~500m x 500m) • an off-the-shelf product and has been corrected for cloud cover and stray light)\nHowever, I find that this data has ongoing problems with snowfall.\nSnow reflects light.\nAnd during Jan and Feb 2021 (the middle of the pandemic), European countries were reporting record-levels of luminosity.\nThis didn’t square with reality.\nInstead, this was caused by snow.\n\nVIIRS Black Marble (provided by (NASA?))\n\nSource 3: VIIRS Black Marble data (provided by NASA)\nThis dataset is more ‘raw’.\nIt provides the tools for pixel-level processing.\nYou’re able to determine:\n• the angle of the satellite • which pixels are obscure by clouds • snowfall & foliage adjusted estimates\nThis is important because:\n• snowfall and water reflects light • foliage and clouds obscures the view of satellites • satellite angles impacts its perception of luminosity\nUsing NASA”s Black Marble VIIRS data, this can all be addressed at a pixel-level.\n\n\n\n\n\nPixel-level cleaning of data is computationally intensive.\nIt requires cloud computing to do this at scale.\nHowever, once cleaned, NASA’s luminosity estimates are less volatile than Colorado School of Mine’s VIIRs estimates.\nDue to stray light, Black Marble has many missing values for northern countries from Jun-Aug.\nThe figure below is from June 2021.\nWhite in the figure below = missing luminosity values.\nTherefore, Black Marble data can’t solely be used for summer months in northern countries."
  },
  {
    "objectID": "nightlights.html#further-readings",
    "href": "nightlights.html#further-readings",
    "title": "Night Lights",
    "section": "Further readings",
    "text": "Further readings\n\nNight Light Stats\nHenderson, J. Vernon, Adam Storeygard, and David N. Weil. 2012. Measuring Economic Growth from Outer Space American Economic Review, 102 (2): 994-1028. Replication data"
  },
  {
    "objectID": "mapraster_code.html#noaa-night-lights-data",
    "href": "mapraster_code.html#noaa-night-lights-data",
    "title": "Lab 1",
    "section": "NOAA Night Lights data",
    "text": "NOAA Night Lights data\n\nImport raster data\n\nMENA_lights &lt;- rast(\"data/MENA_noaa_projected.tif\")\n\nPlot it.\n\nplot(MENA_lights) \n\n\n\n\nHave a look at the CRS.\n\ncrs(MENA_lights)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        DATUM[\\\"World Geodetic System 1984\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Albers Equal Area\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"easting\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]],\\n        AXIS[\\\"northing\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]]]\"\n\n\n\n\nImport the Lebanon shapefile\nImport the Lebanon shapefile, plot it, and verify its Coordinate Reference System (CRS). Is it the same as the raster’s CRS?\n\nMENA_adm1 &lt;- read_sf(\"data/MENA_projected.shp\")\nplot(MENA_adm1$geometry)\n\n\n\ncrs(MENA_adm1)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Not known.\\\"],\\n        AREA[\\\"Africa\\\"],\\n        BBOX[-35,-25,39,55]],\\n    ID[\\\"ESRI\\\",102022]]\"\n\n\n\n\nReproject the Raster\nAs we are using both the raster and terra packages to handle the raster data it is useful to write terra:: or raster:: in front of the function we are using.\nWe use the terra project() function, we need to define two things:\n\nThe object we want to reproject and\nThe CRS that we want to reproject it to.\n\n\nMENA_lights &lt;- terra::project(MENA_lights, crs(MENA_adm1)) # reporjectig the elevation data to the crs of the Lebanon shapefile\ncrs(MENA_lights)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Not known.\\\"],\\n        AREA[\\\"Africa\\\"],\\n        BBOX[-35,-25,39,55]],\\n    ID[\\\"ESRI\\\",102022]]\"\n\n\n\n\nCropping and Masking\nCropping and masking are both spatial operations used in raster data analysis.\nCropping:\n\nPurpose: Cropping a raster involves changing the extent of the raster dataset by specifying a new bounding box or geographic area of interest. The result is a new raster that covers only the specified region.\nTypical Use: Cropping is commonly used when you want to reduce the size of a raster dataset to focus on a smaller geographic area of interest while retaining all the original data values within that area.\n\nMasking:\n\nPurpose: Applying a binary mask to the dataset. The mask is typically a separate raster or polygon layer where certain areas are designated as “masked” (1) or “unmasked” (0).\nTypical Use: Masking is used when you want to extract or isolate specific areas or features within a raster dataset. For example, you might use a mask to extract land cover information within the boundaries of a protected national park.\n\nIn many cases, these cropping and masking are executed one after the other because it is computationally easier to crop when dealing with large datasets, and then masking.\n\nMENA_lights_crop &lt;- crop(MENA_lights, extent(MENA_adm1))\nMENA_lights_mask &lt;- mask(MENA_lights_crop, MENA_adm1)\n\n\n\nPlot elevation\n\nplot(MENA_lights_mask)\nplot(MENA_adm1$geometry, col= NA, add=T)\n\n\n\n\nLet’s improve this a bit. Remember that there is a lot we can do with ColorBrewer.\n\nplottmap\n\n\n\npal = rev(brewer.pal(6,\"YlGnBu\"))\nplot(MENA_lights_mask, breaks=c(0,10,20,30,40,Inf), col=pal)\nplot(MENA_adm1$geometry, col= NA, add=T)\n\n\n\n\n\n\n\n# Define the palette\npal = rev(brewer.pal(6,\"YlGnBu\"))\n\n# Create the base map\ntm_shape(MENA_lights_mask) +\n  tm_raster(breaks = c(0,10,20,30,40,Inf),\n            palette = pal) +  # Plot the raster with breaks and palette\n  tm_shape(MENA_adm1) +\n  tm_borders(lwd = 1, col = \"darkgrey\") +  # Add borders to the administrative boundaries\ntm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = \"right\", \n          title = \"Night light intensity\")  # Remove frame\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\nQuestions to ask yourself about how you can improve these maps, going back to geo-visualisation and choropleths.\n\nWhat are the logical breaks for night lights data?\nWhat should the colours be?\nHave a look at some of the tmap documentation to improve your map further .\n\n\n\n\n\nSpatial join with vector data\nKeep Egypt from all Middle East and North Africa Countries.\n\n# Subset MENA_adm1 to select only Egypt\nEgypt &lt;- MENA_adm1 %&gt;%\n  filter(name == \"Egypt\")\n\n# Crop MENA_adm1 raster to Egypt\nEgypt_lights_mask &lt;- crop(MENA_lights_mask, extent(Egypt))\n\nUsing osmdata package to query amenity data. We only query hospitals to keep it brief.\n\n# creating bounding box for Cairo\negypt_bb &lt;- getbb(\"Cairo Egypt\")\ncairo &lt;- opq(bbox = egypt_bb)\n\n# Getting hospitals in Cairo\namenities &lt;- cairo %&gt;%\n   add_osm_feature(key = \"amenity\", value = c(\"hospital\")) %&gt;%\n   osmdata_sf ()\n\n# checking object and types of data\namenities\n\nObject of class 'osmdata' with:\n                 $bbox : 29.7483062,31.2200331,30.3209168,31.9090054\n        $overpass_call : The call submitted to the overpass API\n                 $meta : metadata including timestamp and version numbers\n           $osm_points : 'sf' Simple Features Collection with 1380 points\n            $osm_lines : NULL\n         $osm_polygons : 'sf' Simple Features Collection with 92 polygons\n       $osm_multilines : NULL\n    $osm_multipolygons : 'sf' Simple Features Collection with 2 multipolygons\n\n\nKeeping just the OSM points from the OSM data.\n\namenities_points &lt;- amenities$osm_points"
  },
  {
    "objectID": "mapraster_code.html#plotting",
    "href": "mapraster_code.html#plotting",
    "title": "Lab 1",
    "section": "Plotting",
    "text": "Plotting\nAn initial plot.\n\n# Plotting\nggplot() + \n  geom_sf(data = amenities$osm_points, fill = 'orange') + \n  geom_spatraster(data=Egypt_lights_mask, alpha = 0.5) +\n  coord_sf(xlim = c(30.852356, 31.717529), ylim = c(29.699982, 30.473532)) + theme_minimal()\n\n&lt;SpatRaster&gt; resampled to 501014 cells for plotting\n\n\n\n\n\nStarting to improve the plot.\n\n# Plotting\nggplot() + \n  geom_sf(data = amenities$osm_points, aes(color = \"Hospitals\"), fill = 'red', size = 1, stroke = 1, color = \"darkred\") + \n  geom_spatraster(data = Egypt_lights_mask, aes(fill = ..value..), alpha = 0.5) +\n  scale_fill_gradient(low = \"black\", high = \"yellow\", name = \"Night Lights\") +\n  coord_sf(xlim = c(30.852356, 31.717529), ylim = c(29.699982, 30.473532)) + \n  labs(title = \"Distribution of Hospitals and Night Lights in Egypt\",\n       x = \"Longitude\", y = \"Latitude\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\nMore on geom_spatraster (here)[https://dieghernan.github.io/tidyterra/reference/geom_spatraster.html]."
  },
  {
    "objectID": "mapraster_code.html#extracting",
    "href": "mapraster_code.html#extracting",
    "title": "Lab 1",
    "section": "Extracting",
    "text": "Extracting\nYou might want to extract values from a raster data set, and then map them in a vector sf framework or extract them to analyse them statistically. If it therefore very useful to know how to extract:\n\n# Using the 'raster::extract' function, it calculates the elevation values at the coordinates of the points. 'elevation' is a raster layer, and 'households' is point data representing household locations.\nlights_hospitals &lt;- raster::extract(Egypt_lights_mask,\n                                amenities_points)\n\n# Attach elevation at each point to the original housesales dataframe\nlights_hospitals &lt;- cbind(amenities_points, lights_hospitals)\n\n# Keep only specified columns\nlights_hospitals &lt;- lights_hospitals %&gt;%\n  select(MENA_noaa_projected, ID, geometry, osm_id)\n\n# Check out the data\nhead(lights_hospitals)\n\nSimple feature collection with 6 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 31.2256 ymin: 30.06897 xmax: 31.29417 ymax: 30.08557\nGeodetic CRS:  WGS 84\n          MENA_noaa_projected ID    osm_id                  geometry\n32538148                   63  1  32538148 POINT (31.29417 30.06897)\n272580023                  63  2 272580023 POINT (31.22562 30.08249)\n272580024                  63  3 272580024  POINT (31.2256 30.08322)\n272580025                  63  4 272580025 POINT (31.22574 30.08381)\n272580026                  63  5 272580026 POINT (31.22597 30.08485)\n272580027                  63  6 272580027 POINT (31.22584 30.08557)\n\n\n\n\n\n\n\n\nImportant\n\n\n\nMake sure all your data is in the same CRS, otherwise the raster::extract function will not work properly.\nYou should not be seeing NAs, if you do you should use the terra project() function.\nThere is also the exactextractor package which we will use in the next section."
  },
  {
    "objectID": "nightlights.html#not-all-satellite-data-is-the-same.",
    "href": "nightlights.html#not-all-satellite-data-is-the-same.",
    "title": "Night Lights",
    "section": "Not all satellite data is the same.",
    "text": "Not all satellite data is the same.\nThere are actually three different sources of free night time data:\n\n1. DMSP-OLS (low-resolution data)\nIt is:\n\nAvailable from 1992-2013,\nLow resolution (each pixel is ~1km x 1km),\nThe most widely used luminosity dataset in spatial economics\n\nIt also faces an issue of ‘overglow’. This is where light from one region is picked up by another region.\n\n\n2. VIIRS (provided by Colorado School of Mines)\nSource 2: VIIRS data (provided by Colorado School of Mines and NOAA)\nThis is:\n\nAvailable from 2012-present\nDoesn’t experience overglow\nHigh resolution (each pixel is ~500m x 500m)\nAn off-the-shelf product and has been corrected for cloud cover and stray light,\n\nHowever, this data has ongoing problems with snowfall.Snow reflects light. And during Jan and Feb 2021 (the middle of the pandemic), European countries were reporting record-levels of luminosity. This didn’t square with reality. Instead, this was caused by snow. We will still be using this as our primary data for this workshop. Colorado School of Mines’s (CSM) VIIRS data is the main dataset used in most studies (of those that use high resolution luminosity data).\n\n\n3. VIIRS Black Marble\nNASA’s Black Marble is quite recent—it was only released in 2021.This dataset is more ‘raw’. It provides the tools for pixel-level processing. And it claims to do things differently by providing ‘cleaner’ luminosity images.\n‘Clean’ luminosity images sounds simple in practice. It’s essentially luminosity data that’s free from sources of noise. But in reality, this is incredibly hard to do.\nIn order to provide ‘clean’ luminosity images we need to account for a few things:\n\nSurface-reflection: luminosity doesn’t reflect off the Earth’s surface (e.g. light bouncing off snow).\nAtmospheric-reflection: luminosity doesn’t reflect off the Earth’s atmosphere (e.g. light bouncing of aerosols or clouds).\nStray light (which comes from the sun directly into the Satellite’s instruments) doesn’t contaminate the images.\nOther issues: such as vegetation obscuring satellite images, the satellite’s angle from the Earth changing luminosity scores, or other outliers like lightning.\n\nI find this GIF from NASA to be pretty helpful in understanding all of these things:\nWith NASA’s Black Marble you’re able to determine:\n\nThe angle of the satellite\nWhich pixels are obscure by clouds\nsnowfall & foliage adjusted estimates\n\nThis is important because:\n\nSnowfall and water reflects light\nFoliage and clouds obscures the view of satellites\nSatellite angles impacts its perception of luminosity\n\n\n\n\n\n\nSome important things to note:\n\nPixel-level cleaning of data is computationally intensive.\nIt requires cloud computing to do this at scale.\nHowever, once cleaned, NASA’s luminosity estimates are less volatile than Colorado School of Mine’s VIIRs estimates.\nDue to stray light, Black Marble has many missing values for northern countries from Jun-Aug."
  },
  {
    "objectID": "nightlights.html#what-economic-activities-do-nightlights-capture",
    "href": "nightlights.html#what-economic-activities-do-nightlights-capture",
    "title": "Night Lights",
    "section": "What economic activities do nightlights capture?",
    "text": "What economic activities do nightlights capture?\nIt’s quite vague to say that nightlights captures ‘economic activity’. What exactly do we mean by economic activity?\nIn the Henderson et al. paper, they use nightlights as a proxy for real GDP growth.\nBut taking a step back, GDP is typically measured in three ways:\n\nAdding up all of the consumption in an economy (this includes investments and government spending)\nAdding up all of the income earned in an economy\nAdding up the value of all things produced in an economy\n\nOn aggregate for an entire country, all of these things should equal one another.\nHowever, we need to be careful about double counting. For example, combining production values with income and consumption figures without accounting for overlaps could distort things.\nThe bottom line: nightlights can capture certain elements of consumption and production."
  },
  {
    "objectID": "Preparing.html#r-basics",
    "href": "Preparing.html#r-basics",
    "title": "Setting up for the workshop",
    "section": "R Basics",
    "text": "R Basics\nTo run the analysis and reproduce the code in R, you need the following software:\n\nR-4.2.2\nRStudio 2022.12.0-353\nThe list of libraries in the next section\n\nTo install and update:\n\nR, download the appropriate version from The Comprehensive R Archive Network (CRAN)\nRStudio, download the appropriate version from Posit\n\nTo check your version of:\n\nR and libraries run sessionInfo()\nRStudio click help on the menu bar and then About\nQuarto check the version file in the quarto folder on your computer.\n\n\nStarting a session\nUpon startup, RStudio will look something like this. Note: the Pane Layout and Appearance settings can be altered e.g. on Mac OS by clicking RStudio&gt;Preferences&gt;Appearance and RStudio&gt;Preferences&gt;Pane Layout. I personally like to have my Console in the top right corner and Environment in the bottom left and keep the Source and Environment panes wider than Console and Files for easier readability. Default settings will probably have the Console in the bottom left and Environment in the top right. You will also have a standard white background; but you can chose specific themes."
  },
  {
    "objectID": "Preparing.html#file-organization",
    "href": "Preparing.html#file-organization",
    "title": "Setting up for the workshop",
    "section": "File organization",
    "text": "File organization\nYou can download the data and code for this workshop here.\nThe data should be set up like in the screenshot below. You will have to download some of the data from websites as you go along."
  },
  {
    "objectID": "Preparing.html#installing-packages",
    "href": "Preparing.html#installing-packages",
    "title": "Setting up for the workshop",
    "section": "Installing Packages",
    "text": "Installing Packages\n\n# Provides various utility functions for R programming.\nlibrary(R.utils)\n# For data manipulation and transformation.\nlibrary(dplyr)\n# Spatial data\nlibrary(sf)\n# Popular data visualization package in R.  \nlibrary(ggplot2)\n# For creating thematic maps \nlibrary(tmap)\n# Color palettes suitable for data visualization, especially for those with color vision deficiencies.\nlibrary(viridis)\n# A collection of color palettes for data visualization.\nlibrary(RColorBrewer)\n# For working with raster data, such as gridded spatial data like satellite imagery or elevation data.\nlibrary(raster)\n# An alternative to the 'raster' package and is used for working with large raster datasets efficiently.\nlibrary(terra)\n# Tools for extracting data from raster layers at exact locations, often used in spatial analysis.\nlibrary(exactextractr)\n# Common methods of the tidyverse packages for objects created with the {terra} package: SpatRaster and SpatVector\nlibrary(tidyterra)\n# Querying Open Street Map data\nlibrary(osmdata)\n\n\n\n\n\n\n\nImportant\n\n\n\nImportant packages for raster data in R.\n\nterra: the best way of loading and processing raster data.\nsf: the go-to package for dealing with polygons, lines and spatial points.\nexactextractor: the quickest, easiest and most accurate way to calculate zonal statistics. It’s an R wrapper for the exactextract package (written in C++). It’s more accurate than ArcGIS, QGIS, and Python’s rasterstats package in calculating zonal stats.\ntmap: quick and easy, and its “view” mode allows you to create interactive maps that are built on leaflet.\nggplot: the best package for building beautiful maps. Allows for more customisation than tmap.\n\nThere are also the following packages which we will not be using in this workshop:\n\nrgeedim: provides the easiest way to download data directly from Google Earth Engine as GeoTiffs.\nrgee: an R wrapper for Google Earth Engine, so you can run GEE commands in R\ngganimate: a package that allows you to turn your ggplot2 graphs into gifs.\nrayshader: create animated 3D graphs and maps in R.\ncountrycode: a useful package to automatically generate ISO codes from country names (and vice versa), assign continents to countries.\ndoparallel: my go-to package for parallel processing."
  },
  {
    "objectID": "nightlights.html#not-all-satellite-data-is-the-same",
    "href": "nightlights.html#not-all-satellite-data-is-the-same",
    "title": "Night Lights",
    "section": "Not all satellite data is the same",
    "text": "Not all satellite data is the same\nThere are actually three different sources of free night time data:\n\n1. DMSP-OLS (low-resolution data)\nIt is:\n\nAvailable from 1992-2013,\nLow resolution (each pixel is ~1km x 1km),\nThe most widely used luminosity dataset in spatial economics\n\nIt also faces an issue of ‘overglow’. This is where light from one region is picked up by another region.\n\n\n2. VIIRS (provided by Colorado School of Mines)\nSource 2: VIIRS data (provided by Colorado School of Mines and NOAA)\nThis is:\n\nAvailable from 2012-present\nDoesn’t experience overglow\nHigh resolution (each pixel is ~500m x 500m)\nAn off-the-shelf product and has been corrected for cloud cover and stray light,\n\nHowever, this data has ongoing problems with snowfall.Snow reflects light. And during Jan and Feb 2021 (the middle of the pandemic), European countries were reporting record-levels of luminosity. This didn’t square with reality. Instead, this was caused by snow. We will still be using this as our primary data for this workshop. Colorado School of Mines’s (CSM) VIIRS data is the main dataset used in most studies (of those that use high resolution luminosity data).\n\n\n3. VIIRS Black Marble\nNASA’s Black Marble is quite recent—it was only released in 2021.This dataset is more ‘raw’. It provides the tools for pixel-level processing. And it claims to do things differently by providing ‘cleaner’ luminosity images.\n‘Clean’ luminosity images sounds simple in practice. It’s essentially luminosity data that’s free from sources of noise. But in reality, this is incredibly hard to do.\nIn order to provide ‘clean’ luminosity images we need to account for a few things:\n\nSurface-reflection: luminosity doesn’t reflect off the Earth’s surface (e.g. light bouncing off snow).\nAtmospheric-reflection: luminosity doesn’t reflect off the Earth’s atmosphere (e.g. light bouncing of aerosols or clouds).\nStray light (which comes from the sun directly into the Satellite’s instruments) doesn’t contaminate the images.\nOther issues: such as vegetation obscuring satellite images, the satellite’s angle from the Earth changing luminosity scores, or other outliers like lightning.\n\nI find this GIF from NASA to be pretty helpful in understanding all of these things:\nWith NASA’s Black Marble you’re able to determine:\n\nThe angle of the satellite\nWhich pixels are obscure by clouds\nsnowfall & foliage adjusted estimates\n\nThis is important because:\n\nSnowfall and water reflects light\nFoliage and clouds obscures the view of satellites\nSatellite angles impacts its perception of luminosity\n\n\n\n\n\n\nSome important things to note:\n\nPixel-level cleaning of data is computationally intensive.\nIt requires cloud computing to do this at scale.\nHowever, once cleaned, NASA’s luminosity estimates are less volatile than Colorado School of Mine’s VIIRs estimates.\nDue to stray light, Black Marble has many missing values for northern countries from Jun-Aug."
  },
  {
    "objectID": "preparing.html#r-basics",
    "href": "preparing.html#r-basics",
    "title": "Setting up for the workshop",
    "section": "R Basics",
    "text": "R Basics\nTo run the analysis and reproduce the code in R, you need the following software:\n\nR-4.2.2\nRStudio 2022.12.0-353\nThe list of libraries in the next section\n\nTo install and update:\n\nR, download the appropriate version from The Comprehensive R Archive Network (CRAN)\nRStudio, download the appropriate version from Posit\n\nTo check your version of:\n\nR and libraries run sessionInfo()\nRStudio click help on the menu bar and then About\nQuarto check the version file in the quarto folder on your computer.\n\n\nStarting a session\nUpon startup, RStudio will look something like this. Note: the Pane Layout and Appearance settings can be altered e.g. on Mac OS by clicking RStudio&gt;Preferences&gt;Appearance and RStudio&gt;Preferences&gt;Pane Layout. I personally like to have my Console in the top right corner and Environment in the bottom left and keep the Source and Environment panes wider than Console and Files for easier readability. Default settings will probably have the Console in the bottom left and Environment in the top right. You will also have a standard white background; but you can chose specific themes."
  },
  {
    "objectID": "preparing.html#file-organization",
    "href": "preparing.html#file-organization",
    "title": "Setting up for the workshop",
    "section": "File organization",
    "text": "File organization\nYou can download the data and code for this workshop here.\nThe data should be set up like in the screenshot below. You will have to download some of the data from websites as you go along."
  },
  {
    "objectID": "preparing.html#installing-packages",
    "href": "preparing.html#installing-packages",
    "title": "Setting up for the workshop",
    "section": "Installing Packages",
    "text": "Installing Packages\n\n# Provides various utility functions for R programming.\nlibrary(R.utils)\n# For data manipulation and transformation.\nlibrary(dplyr)\n# Spatial data\nlibrary(sf)\n# Popular data visualization package in R.  \nlibrary(ggplot2)\n# For creating thematic maps \nlibrary(tmap)\n# Color palettes suitable for data visualization, especially for those with color vision deficiencies.\nlibrary(viridis)\n# A collection of color palettes for data visualization.\nlibrary(RColorBrewer)\n# For working with raster data, such as gridded spatial data like satellite imagery or elevation data.\nlibrary(raster)\n# An alternative to the 'raster' package and is used for working with large raster datasets efficiently.\nlibrary(terra)\n# Tools for extracting data from raster layers at exact locations, often used in spatial analysis.\nlibrary(exactextractr)\n# Common methods of the tidyverse packages for objects created with the {terra} package: SpatRaster and SpatVector\nlibrary(tidyterra)\n# Querying Open Street Map data\nlibrary(osmdata)\n\n\n\n\n\n\n\nImportant\n\n\n\nImportant packages for raster data in R.\n\nterra: the best way of loading and processing raster data.\nsf: the go-to package for dealing with polygons, lines and spatial points.\nexactextractor: the quickest, easiest and most accurate way to calculate zonal statistics. It’s an R wrapper for the exactextract package (written in C++). It’s more accurate than ArcGIS, QGIS, and Python’s rasterstats package in calculating zonal stats.\ntmap: quick and easy, and its “view” mode allows you to create interactive maps that are built on leaflet.\nggplot: the best package for building beautiful maps. Allows for more customisation than tmap.\n\nThere are also the following packages which we will not be using in this workshop:\n\nrgeedim: provides the easiest way to download data directly from Google Earth Engine as GeoTiffs.\nrgee: an R wrapper for Google Earth Engine, so you can run GEE commands in R\ngganimate: a package that allows you to turn your ggplot2 graphs into gifs.\nrayshader: create animated 3D graphs and maps in R.\ncountrycode: a useful package to automatically generate ISO codes from country names (and vice versa), assign continents to countries.\ndoparallel: my go-to package for parallel processing."
  },
  {
    "objectID": "maprasterDIY.html#option-1",
    "href": "maprasterDIY.html#option-1",
    "title": "Do-It-Yourself",
    "section": "Option 1",
    "text": "Option 1\nWorking on a time-series representation of the evolution of Nights Lights in a country of your choice. As in the lab, the data can be found here.\n\nProcess the data and make a map with at least two years of night lights data.\nThink about the story the data is telling you.\n\nHow have night lights evolved over time in your country of choice? Remember this will mean different things for different countries.\nWhat choices have you made in terms of bins, colours, zoom level to tell your story?"
  },
  {
    "objectID": "maprasterDIY.html#option-2",
    "href": "maprasterDIY.html#option-2",
    "title": "Do-It-Yourself",
    "section": "Option 2",
    "text": "Option 2\nIntroducing NASA’s Black Marble dataset\n\nFollowing the Tutorial Downloading and processing Black Marble nightlights data in R\nhttps://yohaniddawela.substack.com/p/tutorial-downloading-and-processing\n\n\nTutorial: How to increase the resolution of nightlights data\nThe exact steps and codebase to increase nightlights from ~500m to ~30m resolution"
  },
  {
    "objectID": "mapnight1.html#noaa-night-lights-data",
    "href": "mapnight1.html#noaa-night-lights-data",
    "title": "Lab 1",
    "section": "NOAA Night Lights data",
    "text": "NOAA Night Lights data\n\nImport raster data\n\nMENA_lights &lt;- rast(\"data/MENA_noaa_projected.tif\")\n\nPlot it.\n\nplot(MENA_lights) \n\n\n\n\nHave a look at the CRS.\n\ncrs(MENA_lights)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        DATUM[\\\"World Geodetic System 1984\\\",\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Albers Equal Area\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"easting\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]],\\n        AXIS[\\\"northing\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1,\\n                ID[\\\"EPSG\\\",9001]]]]\"\n\n\n\n\nImport the MENA shapefile\nImport the Middle East and North Africa (MENA) shapefile, plot it, and verify its Coordinate Reference System (CRS). Is it the same as the raster’s CRS?\n\nMENA_adm1 &lt;- read_sf(\"data/MENA_projected.shp\")\nplot(MENA_adm1$geometry)\n\n\n\ncrs(MENA_adm1)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Not known.\\\"],\\n        AREA[\\\"Africa\\\"],\\n        BBOX[-35,-25,39,55]],\\n    ID[\\\"ESRI\\\",102022]]\"\n\n\n\n\nReproject the Raster\nAs we are using both the raster and terra packages to handle the raster data it is useful to write terra:: or raster:: in front of the function we are using.\nWe use the terra project() function, we need to define two things:\n\nThe object we want to reproject and\nThe CRS that we want to reproject it to.\n\n\nMENA_lights &lt;- terra::project(MENA_lights, crs(MENA_adm1)) # reporjectig the raster data to the crs of the MENA shapefile\ncrs(MENA_lights)\n\n[1] \"PROJCRS[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n    BASEGEOGCRS[\\\"WGS 84\\\",\\n        ENSEMBLE[\\\"World Geodetic System 1984 ensemble\\\",\\n            MEMBER[\\\"World Geodetic System 1984 (Transit)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G730)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G873)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1150)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1674)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G1762)\\\"],\\n            MEMBER[\\\"World Geodetic System 1984 (G2139)\\\"],\\n            ELLIPSOID[\\\"WGS 84\\\",6378137,298.257223563,\\n                LENGTHUNIT[\\\"metre\\\",1]],\\n            ENSEMBLEACCURACY[2.0]],\\n        PRIMEM[\\\"Greenwich\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433]],\\n        ID[\\\"EPSG\\\",4326]],\\n    CONVERSION[\\\"Africa_Albers_Equal_Area_Conic\\\",\\n        METHOD[\\\"Albers Equal Area\\\",\\n            ID[\\\"EPSG\\\",9822]],\\n        PARAMETER[\\\"Latitude of false origin\\\",0,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8821]],\\n        PARAMETER[\\\"Longitude of false origin\\\",25,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8822]],\\n        PARAMETER[\\\"Latitude of 1st standard parallel\\\",20,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8823]],\\n        PARAMETER[\\\"Latitude of 2nd standard parallel\\\",-23,\\n            ANGLEUNIT[\\\"degree\\\",0.0174532925199433],\\n            ID[\\\"EPSG\\\",8824]],\\n        PARAMETER[\\\"Easting at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8826]],\\n        PARAMETER[\\\"Northing at false origin\\\",0,\\n            LENGTHUNIT[\\\"metre\\\",1],\\n            ID[\\\"EPSG\\\",8827]]],\\n    CS[Cartesian,2],\\n        AXIS[\\\"(E)\\\",east,\\n            ORDER[1],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n        AXIS[\\\"(N)\\\",north,\\n            ORDER[2],\\n            LENGTHUNIT[\\\"metre\\\",1]],\\n    USAGE[\\n        SCOPE[\\\"Not known.\\\"],\\n        AREA[\\\"Africa\\\"],\\n        BBOX[-35,-25,39,55]],\\n    ID[\\\"ESRI\\\",102022]]\"\n\n\n\n\nCropping and Masking\nCropping and masking are both spatial operations used in raster data analysis.\nCropping:\n\nPurpose: Cropping a raster involves changing the extent of the raster dataset by specifying a new bounding box or geographic area of interest. The result is a new raster that covers only the specified region.\nTypical Use: Cropping is commonly used when you want to reduce the size of a raster dataset to focus on a smaller geographic area of interest while retaining all the original data values within that area.\n\nMasking:\n\nPurpose: Applying a binary mask to the dataset. The mask is typically a separate raster or polygon layer where certain areas are designated as “masked” (1) or “unmasked” (0).\nTypical Use: Masking is used when you want to extract or isolate specific areas or features within a raster dataset. For example, you might use a mask to extract land cover information within the boundaries of a protected national park.\n\nIn many cases, these cropping and masking are executed one after the other because it is computationally easier to crop when dealing with large datasets, and then masking.\n\nMENA_lights_crop &lt;- crop(MENA_lights, extent(MENA_adm1))\nMENA_lights_mask &lt;- mask(MENA_lights_crop, MENA_adm1)\n\n\n\nSimple plot\n\nplot(MENA_lights_mask)\nplot(MENA_adm1$geometry, col= NA, add=T)\n\n\n\n\nLet’s improve this a bit. Remember that there is a lot we can do with ColorBrewer.\n\nplottmap\n\n\n\npal = rev(brewer.pal(6,\"YlGnBu\"))\nplot(MENA_lights_mask, breaks=c(0,10,20,30,40,Inf), col=pal)\nplot(MENA_adm1$geometry, col= NA, add=T)\n\n\n\n\n\n\n\n# Define the palette\npal = rev(brewer.pal(6,\"YlGnBu\"))\n\n# Create the base map\ntm_shape(MENA_lights_mask) +\n  tm_raster(breaks = c(0,10,20,30,40,Inf),\n            palette = pal) +  # Plot the raster with breaks and palette\n  tm_shape(MENA_adm1) +\n  tm_borders(lwd = 1, col = \"darkgrey\") +  # Add borders to the administrative boundaries\ntm_layout(frame = FALSE, legend.outside = TRUE, legend.outside.position = \"right\", \n          title = \"Night light intensity\")  # Remove frame\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestions\n\n\n\nQuestions to ask yourself about how you can improve these maps, going back to geo-visualisation and choropleths.\n\nWhat are the logical breaks for night lights data?\nWhat should the colours be?\nHave a look at some of the tmap documentation to improve your map further .\n\n\n\n\n\nSpatial join with vector data\nKeep Egypt from all Middle East and North Africa Countries.\n\n# Subset MENA_adm1 to select only Egypt\nEgypt &lt;- MENA_adm1 %&gt;%\n  filter(name == \"Egypt\")\n\n# Crop MENA_adm1 raster to Egypt\nEgypt_lights_mask &lt;- crop(MENA_lights_mask, extent(Egypt))\n\nUsing osmdata package to query amenity data. We only query hospitals to keep it brief.\n\n# creating bounding box for Cairo\negypt_bb &lt;- getbb(\"Cairo Egypt\")\ncairo &lt;- opq(bbox = egypt_bb)\n\n# Getting hospitals in Cairo\namenities &lt;- cairo %&gt;%\n   add_osm_feature(key = \"amenity\", value = c(\"hospital\")) %&gt;%\n   osmdata_sf ()\n\n# checking object and types of data\namenities\n\nObject of class 'osmdata' with:\n                 $bbox : 29.7483062,31.2200331,30.3209168,31.9090054\n        $overpass_call : The call submitted to the overpass API\n                 $meta : metadata including timestamp and version numbers\n           $osm_points : 'sf' Simple Features Collection with 1380 points\n            $osm_lines : NULL\n         $osm_polygons : 'sf' Simple Features Collection with 92 polygons\n       $osm_multilines : NULL\n    $osm_multipolygons : 'sf' Simple Features Collection with 2 multipolygons\n\n\nKeeping just the OSM points from the OSM data.\n\namenities_points &lt;- amenities$osm_points"
  },
  {
    "objectID": "mapnight1.html#plotting",
    "href": "mapnight1.html#plotting",
    "title": "Lab 1",
    "section": "Plotting",
    "text": "Plotting\nAn initial plot.\n\n# Plotting\nggplot() + \n  geom_sf(data = amenities$osm_points, fill = 'orange') + \n  geom_spatraster(data=Egypt_lights_mask, alpha = 0.5) +\n  coord_sf(xlim = c(30.852356, 31.717529), ylim = c(29.699982, 30.473532)) + theme_minimal()\n\n&lt;SpatRaster&gt; resampled to 501014 cells for plotting\n\n\n\n\n\nStarting to improve the plot.\n\n# Plotting\nggplot() + \n  geom_sf(data = amenities$osm_points, aes(color = \"Hospitals\"), fill = 'red', size = 1, stroke = 1, color = \"darkred\") + \n  geom_spatraster(data = Egypt_lights_mask, aes(fill = ..value..), alpha = 0.5) +\n  scale_fill_gradient(low = \"black\", high = \"yellow\", name = \"Night Lights\") +\n  coord_sf(xlim = c(30.852356, 31.717529), ylim = c(29.699982, 30.473532)) + \n  labs(title = \"Distribution of Hospitals and Night Lights in Egypt\",\n       x = \"Longitude\", y = \"Latitude\") +\n  theme_minimal() +\n  theme(legend.position = \"bottom\")\n\n\n\n\nMore on geom_spatraster (here)[https://dieghernan.github.io/tidyterra/reference/geom_spatraster.html]."
  },
  {
    "objectID": "mapnight1.html#extracting",
    "href": "mapnight1.html#extracting",
    "title": "Lab 1",
    "section": "Extracting",
    "text": "Extracting\nYou might want to extract values from a raster data set, and then map them in a vector sf framework or extract them to analyse them statistically. If it therefore very useful to know how to extract:\n\n# Using the 'raster::extract' function, it calculates the illumination values at the coordinates of the points. \nlights_hospitals &lt;- raster::extract(Egypt_lights_mask,\n                                amenities_points)\n\n# Attach nightlight data at each point to the amenities dataframe\nlights_hospitals &lt;- cbind(amenities_points, lights_hospitals)\n\n# Keep only specified columns\nlights_hospitals &lt;- lights_hospitals %&gt;%\n  select(MENA_noaa_projected, ID, geometry, osm_id)\n\n# Check out the data\nhead(lights_hospitals)\n\nSimple feature collection with 6 features and 3 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 31.2256 ymin: 30.06897 xmax: 31.29417 ymax: 30.08557\nGeodetic CRS:  WGS 84\n          MENA_noaa_projected ID    osm_id                  geometry\n32538148                   63  1  32538148 POINT (31.29417 30.06897)\n272580023                  63  2 272580023 POINT (31.22562 30.08249)\n272580024                  63  3 272580024  POINT (31.2256 30.08322)\n272580025                  63  4 272580025 POINT (31.22574 30.08381)\n272580026                  63  5 272580026 POINT (31.22597 30.08485)\n272580027                  63  6 272580027 POINT (31.22584 30.08557)\n\n\n\n\n\n\n\n\nImportant\n\n\n\nMake sure all your data is in the same CRS, otherwise the raster::extract function will not work properly.\nYou should not be seeing NAs, if you do you should use the terra project() function.\nThere is also the exactextractor package which we will use in the next section."
  }
]